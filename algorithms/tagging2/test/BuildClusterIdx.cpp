 /*
  * ./BuildClusterIdx -model ../data/cluster.model -idx ../data/cluster.idx [-ntrees xx]
  * -ntrees 指定树的个数，默认等于cluster的个数, 值越大则生成的idx文件也越大，但查找速度会更快
  */
#include <iostream>
#include <fstream>
#include <sstream>
#include <memory>
#include <glog/logging.h>
#include <gflags/gflags.h>
#include "common.hpp"
#include "AnnDB.hpp"

using namespace std;

DEFINE_string(model, "", "Cluster info file generated by warplda");
DEFINE_string(idx, "", "Out index file");
DEFINE_int32(ntrees, 0, "number of trees");


typedef float      FLOAT;
static std::unique_ptr<AnnDB<uint32_t, FLOAT> >     g_pAnnDB;


static
void build_idx()
{
    // check idx
    {
        THROW_RUNTIME_ERROR_IF(FLAGS_idx.empty(), "-idx not specified!");
        ofstream ofs(FLAGS_idx, ios::out);
        THROW_RUNTIME_ERROR_IF(!ofs, "Cannot write file " << FLAGS_idx);
    }

    THROW_RUNTIME_ERROR_IF(FLAGS_model.empty(), "-model not specified!");
    ifstream ifs(FLAGS_model, ios::in);
    THROW_RUNTIME_ERROR_IF(!ifs, "Cannot read model file " << FLAGS_model);

    string line;
    uint32_t nClusters = 0, nFeatures = 0;
    
    // skip 1st line
    if (!getline(ifs, line))
        THROW_RUNTIME_ERROR("bad model file!");

    // read nClusters
    if (!getline(ifs, line))
        THROW_RUNTIME_ERROR("bad model file!");
    {
        uint32_t k = 0;
        stringstream ss(line);
        ss >> k;
        if (ss.fail() || ss.bad() || k <= 0)
            THROW_RUNTIME_ERROR("fail to read nClusters!");
        nClusters = k;
    }

    // read nFeatures
    if (!getline(ifs, line))
        THROW_RUNTIME_ERROR("bad model file!");
    {
        uint32_t nf = 0;
        stringstream ss(line);
        ss >> nf;
        if (ss.fail() || ss.bad() || nf <= 0)
            THROW_RUNTIME_ERROR("fail to read nFeatures!");
        nFeatures = nf;
    }
    cout << "nfeatures = " << nFeatures << endl;

    g_pAnnDB.reset(new AnnDB<uint32_t, FLOAT>(nFeatures));

    if (FLAGS_ntrees <= 0) 
        FLAGS_ntrees = nClusters;

    vector<FLOAT> vec;
    for (uint32_t i = 0; i != nClusters; ++i) {
        if (!getline(ifs, line))
            THROW_RUNTIME_ERROR("error while reading cluster matrix lineno = " << i);
        vec.assign(nFeatures, 0.0);
        string item;
        uint32_t idx = 0;   // starts from 1
        FLOAT val = 0.0;
        istringstream ss(line);
        while (ss >> item) {
            if (sscanf(item.c_str(), "%u:%f", &idx, &val) != 2 || idx < 1 || idx > nFeatures)
                continue;
            vec[idx-1] = val;
        } // while
        g_pAnnDB->addItem(vec);
    } // for

    g_pAnnDB->buildIndex(FLAGS_ntrees);
    g_pAnnDB->saveIndex(FLAGS_idx.c_str());
}


static
void test()
{

}


int main(int argc, char **argv)
try {
    google::InitGoogleLogging(argv[0]);
    gflags::ParseCommandLineFlags(&argc, &argv, true);

    build_idx();

    // DLOG(INFO) << g_pAnnDB->size() << " clusters in the tree.";
    // test();

} catch (const std::exception &ex) {
    std::cerr << "Exception caught by main: " << ex.what() << std::endl;
}



